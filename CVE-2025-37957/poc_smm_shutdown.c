#define _GNU_SOURCE
#include <linux/kvm.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <stdint.h> // ✅ Added for uint64_t

#define GUEST_MEM_SIZE 0x10000

void fatal(const char *msg) {
    perror(msg);
    exit(1);
}

int main() {
    int kvm_fd = open("/dev/kvm", O_RDWR);
    if (kvm_fd < 0) fatal("open /dev/kvm");

    int vm_fd = ioctl(kvm_fd, KVM_CREATE_VM, 0);
    if (vm_fd < 0) fatal("KVM_CREATE_VM");

    void *guest_mem = mmap(NULL, GUEST_MEM_SIZE,
                           PROT_READ | PROT_WRITE,
                           MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (guest_mem == MAP_FAILED) fatal("mmap guest_mem");

    struct kvm_userspace_memory_region region = {
        .slot = 0,
        .guest_phys_addr = 0x100000,
        .memory_size = GUEST_MEM_SIZE,
        .userspace_addr = (uint64_t)guest_mem,  // ✅ Now valid
    };

    if (ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &region) < 0)
        fatal("KVM_SET_USER_MEMORY_REGION");

    int vcpu_fd = ioctl(vm_fd, KVM_CREATE_VCPU, 0);
    if (vcpu_fd < 0) fatal("KVM_CREATE_VCPU");

    size_t vcpu_mmap_size = ioctl(kvm_fd, KVM_GET_VCPU_MMAP_SIZE, 0);
    struct kvm_run *run = mmap(NULL, vcpu_mmap_size, PROT_READ | PROT_WRITE,
                               MAP_SHARED, vcpu_fd, 0);
    if (run == MAP_FAILED) fatal("mmap vcpu_run");

    // Enter SMM (System Management Mode)
    if (ioctl(vcpu_fd, KVM_SMI) < 0) {
        fatal("KVM_SMI");
    }
    printf("Entered SMM mode\n");

    // Invalid instructions to cause triple fault
    memset(guest_mem, 0xff, 0x10);  // Fill with invalid opcodes

    struct kvm_regs regs = {
        .rip = 0x100000,
    };
    ioctl(vcpu_fd, KVM_SET_REGS, &regs);

    printf("Running VM to cause triple fault...\n");
    ioctl(vcpu_fd, KVM_RUN, 0);

    printf("KVM_RUN finished\n");
    return 0;
}

